<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#000000" />
  <title>RSVP Speed Reader</title>

  <!-- PDF.js (for loading PDFs) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.js"></script>

  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --accent:#ff3b30;
      --muted:#a0a0a0;
      --card:#111;
      --border:#222;
      --btn:#1c1c1e;
      --btn2:#2c2c2e;

      --rsvpScale: 1.0; /* 0.2 - 2.0 => 20% - 200% */
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{
      margin:0; height:100%; background:var(--bg); color:var(--fg);
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    /* Make sliders red on iOS */
    input[type="range"]{
      accent-color: var(--accent);
    }

    .app{
      min-height:100%;
      padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom) 16px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    header{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      padding-top:10px;
    }

    .title{
      font-weight:900;
      letter-spacing:0.2px;
      font-size:20px;
    }

    .subtitle{
      color:var(--muted);
      font-size:12px;
      margin-top:4px;
    }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
    }

    .hint{
      color:var(--muted);
      font-size:12px;
      line-height:1.35;
    }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    button{
      border:none;
      border-radius:14px;
      padding:14px 14px;
      font-size:16px;
      font-weight:950;
      background:var(--btn2);
      color:var(--fg);
    }
    .primary{
      background:var(--accent);
      color:#000;
    }

    .miniBtn{
      padding:10px 12px;
      border-radius:12px;
      background:var(--btn);
      border:1px solid var(--border);
      font-weight:950;
      font-size:14px;
    }

    input, select{
      background:#050505;
      color:var(--fg);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
      outline:none;
      flex:1;
      min-width: 160px;
    }

    textarea{
      width:100%;
      min-height:170px;
      resize:none;
      border-radius:12px;
      border:1px solid var(--border);
      background:#050505;
      color:var(--fg);
      padding:12px;
      font-size:15px;
      line-height:1.35;
      outline:none;
    }
    textarea::placeholder{ color:#666; }

    .actions{
      display:flex;
      gap:10px;
    }

    .sliderWrap{
      display:flex;
      align-items:center;
      gap:12px;
      margin-top:10px;
    }
    .sliderWrap label{
      font-weight:900;
      min-width: 70px;
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      background:#0b0b0b;
      border:1px solid var(--border);
      font-size:12px;
      color:var(--muted);
      font-weight:900;
      min-width:72px;
      text-align:center;
    }

    .resumeNote{
      margin-top:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    /* Reading overlay (clean) */
    .overlay{
      position:fixed;
      inset:0;
      background:#000;
      display:none;
      align-items:center;
      justify-content:center;
      padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom) 16px;
      z-index:9999;
    }
    .overlay.show{ display:flex; }

    .tapCatcher{
      position:absolute;
      inset:0;
      background:transparent;
    }

    .topBar{
      position:absolute;
      top: env(safe-area-inset-top);
      left:0; right:0;
      padding: 10px 16px 8px 16px;
      display:flex;
      justify-content:flex-end;
      pointer-events:none;
    }
    .topBar > *{ pointer-events:auto; }

    .smallBtn{
      padding:10px 12px;
      border-radius:12px;
      background:rgba(28,28,30,0.75);
      border:1px solid rgba(34,34,34,0.9);
      font-weight:950;
      font-size:14px;
      color:var(--fg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .overlayInner{
      width:100%;
      max-width:680px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      user-select:none;
    }

    .wordBox{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:180px;
      padding: 0 6px;
    }

    .word{
      font-weight:950;
      font-size: calc(clamp(44px, 8vw, 90px) * var(--rsvpScale));
      letter-spacing: 0.5px;
      line-height:1;
      display:flex;
      align-items:baseline;
      justify-content:center;
      font-variant-ligatures:none;
      text-align:center;
    }

    .left, .right{
      display:inline-block;
      min-width: 2ch;
      text-align:right;
      color:var(--fg);
      opacity:0.96;
    }
    .right{
      text-align:left;
    }

    .center{
      color:var(--accent);
      padding:0 2px;
      text-shadow: 0 0 10px rgba(255,59,48,0.12);
    }

    /* Bottom progress bar */
    .progressWrap{
      position:absolute;
      left:0; right:0;
      bottom: env(safe-area-inset-bottom);
      padding: 0 16px 10px 16px;
      pointer-events:none;
    }
    .progressBar{
      height:4px;
      border-radius:999px;
      background:#222;
      overflow:hidden;
    }
    .progressFill{
      height:100%;
      width:0%;
      background:#666;
      border-radius:999px;
      transition: width 90ms linear;
    }
  </style>
</head>

<body>
  <div class="app" id="home">
    <header>
      <div>
        <div class="title">RSVP Speed Reader</div>
        <div class="subtitle">
          Reading: tap to pause/resume • swipe sentence only when paused
        </div>
      </div>
    </header>

    <div class="card">
      <div style="font-weight:950; margin-bottom:10px;">Speed</div>

      <!-- WPM slider (100-step) -->
      <div class="sliderWrap">
        <label for="wpmSlider">WPM</label>
        <input type="range" id="wpmSlider" min="100" max="900" step="100" value="300" />
        <div class="pill" id="wpmLabel">300</div>
      </div>
      <div class="hint">100 WPM steps (100 → 900)</div>

      <!-- Text size slider 20% to 200% -->
      <div class="sliderWrap" style="margin-top:14px;">
        <label for="sizeSlider">Size</label>
        <input type="range" id="sizeSlider" min="0.2" max="2.0" step="0.05" value="1.0" />
        <div class="pill" id="sizeLabel">100%</div>
      </div>
      <div class="hint">20% → 200% RSVP text size</div>
    </div>

    <div class="card">
      <div style="font-weight:950; margin-bottom:10px;">Text</div>

      <!-- PDF load -->
      <div class="row" style="margin-bottom:10px;">
        <button class="miniBtn" id="pdfBtn">Load PDF</button>
        <div class="hint" id="pdfStatus" style="flex:1;">PDF text will be inserted below.</div>
      </div>
      <input id="pdfInput" type="file" accept="application/pdf" style="display:none;" />

      <!-- Save/Load -->
      <div class="row" style="margin-bottom:10px;">
        <input id="saveName" placeholder="Name (e.g. Article 1)" />
        <button class="miniBtn" id="saveBtn">Save</button>
      </div>

      <div class="row" style="margin-bottom:10px;">
        <select id="savedSelect">
          <option value="">Load saved text…</option>
        </select>
        <button class="miniBtn" id="loadBtn">Load</button>
        <button class="miniBtn" id="deleteBtn">Delete</button>
      </div>

      <textarea id="textInput" placeholder="Paste or type your text here..."></textarea>

      <div class="resumeNote">
        <div class="hint" id="resumeHint">No saved progress loaded.</div>
        <button class="miniBtn" id="restartBtn">Restart</button>
      </div>

      <div class="hint" style="margin-top:10px;">
        iPhone: Safari → Share → <b>Add to Home Screen</b>
      </div>
    </div>

    <div class="actions">
      <button class="primary" id="startBtn" style="flex:1;">Start Reading</button>
      <button id="clearBtn">Clear</button>
    </div>
  </div>

  <!-- Reading overlay -->
  <div class="overlay" id="overlay">
    <div class="tapCatcher" id="tapCatcher" aria-label="Tap to pause/resume"></div>

    <div class="topBar">
      <button class="smallBtn" id="exitBtn">Exit</button>
    </div>

    <div class="overlayInner">
      <div class="wordBox">
        <div class="word" aria-live="polite" aria-atomic="true">
          <span class="left" id="leftPart"></span>
          <span class="center" id="centerPart"></span>
          <span class="right" id="rightPart"></span>
        </div>
      </div>
    </div>

    <div class="progressWrap">
      <div class="progressBar">
        <div class="progressFill" id="progressFill"></div>
      </div>
    </div>
  </div>

  <script>
    // -------------------------
    // LocalStorage keys
    // -------------------------
    const STORE_KEY_TEXTS = "rsvp_saved_texts_v3";
    const STORE_KEY_PREFS = "rsvp_prefs_v2";

    // saved map shape:
    // {
    //   "Name": { text: "...", progressWordIndex: 123, updatedAt: 1234567890 }
    // }

    // -------------------------
    // State
    // -------------------------
    let selectedWpm = 300;

    let currentDocName = "";
    let currentDocText = "";
    let lastPersistedIdx = -1;

    let words = [];
    let idx = 0;
    let timer = null;
    let isPlaying = false;

    // sentence navigation support
    let sentenceStarts = [];
    let wordToSentence = [];

    // -------------------------
    // DOM refs
    // -------------------------
    const wpmSlider = document.getElementById('wpmSlider');
    const wpmLabel  = document.getElementById('wpmLabel');

    const sizeSlider = document.getElementById('sizeSlider');
    const sizeLabel = document.getElementById('sizeLabel');

    const pdfBtn = document.getElementById('pdfBtn');
    const pdfInput = document.getElementById('pdfInput');
    const pdfStatus = document.getElementById('pdfStatus');

    const saveName = document.getElementById('saveName');
    const saveBtn = document.getElementById('saveBtn');
    const savedSelect = document.getElementById('savedSelect');
    const loadBtn = document.getElementById('loadBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const restartBtn = document.getElementById('restartBtn');

    const resumeHint = document.getElementById('resumeHint');

    const textInput = document.getElementById('textInput');
    const startBtn = document.getElementById('startBtn');
    const clearBtn = document.getElementById('clearBtn');

    const overlay = document.getElementById('overlay');
    const exitBtn = document.getElementById('exitBtn');
    const tapCatcher = document.getElementById('tapCatcher');

    const leftPart = document.getElementById('leftPart');
    const centerPart = document.getElementById('centerPart');
    const rightPart = document.getElementById('rightPart');

    const progressFill = document.getElementById('progressFill');

    // -------------------------
    // Storage helpers
    // -------------------------
    function loadSavedTexts() {
      try { return JSON.parse(localStorage.getItem(STORE_KEY_TEXTS) || "{}"); }
      catch { return {}; }
    }

    function saveSavedTexts(map) {
      localStorage.setItem(STORE_KEY_TEXTS, JSON.stringify(map));
    }

    function refreshSavedDropdown() {
      const map = loadSavedTexts();
      const current = savedSelect.value;

      savedSelect.innerHTML = '<option value="">Load saved text…</option>';

      Object.keys(map).sort((a,b)=>a.localeCompare(b)).forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        savedSelect.appendChild(opt);
      });

      if (current && map[current]) savedSelect.value = current;
    }

    // -------------------------
    // Prefs
    // -------------------------
    function loadPrefs() {
      try { return JSON.parse(localStorage.getItem(STORE_KEY_PREFS) || "{}"); }
      catch { return {}; }
    }

    function savePrefs() {
      localStorage.setItem(STORE_KEY_PREFS, JSON.stringify({
        wpm: selectedWpm,
        scale: parseFloat(sizeSlider.value)
      }));
    }

    function applyPrefs() {
      const prefs = loadPrefs();
      if (prefs.wpm) {
        const w = Math.max(100, Math.min(900, Math.round(prefs.wpm / 100) * 100));
        selectedWpm = w;
        wpmSlider.value = String(w);
        wpmLabel.textContent = String(w);
      } else {
        selectedWpm = parseInt(wpmSlider.value, 10);
        wpmLabel.textContent = String(selectedWpm);
      }

      if (prefs.scale) {
        const s = Math.max(0.2, Math.min(2.0, prefs.scale));
        sizeSlider.value = s;
        setRsvpScale(s);
      } else {
        setRsvpScale(parseFloat(sizeSlider.value));
      }
    }

    // -------------------------
    // WPM slider
    // -------------------------
    wpmSlider.addEventListener('input', () => {
      selectedWpm = parseInt(wpmSlider.value, 10);
      wpmLabel.textContent = String(selectedWpm);
      savePrefs();
    });

    // -------------------------
    // Text size slider (20-200%)
    // -------------------------
    function setRsvpScale(scale) {
      document.documentElement.style.setProperty('--rsvpScale', String(scale));
      sizeLabel.textContent = Math.round(scale * 100) + "%";
    }

    sizeSlider.addEventListener('input', () => {
      setRsvpScale(parseFloat(sizeSlider.value));
      savePrefs();
    });

    // -------------------------
    // Text utilities
    // -------------------------
    function normalizeText(str) {
      return str
        .replace(/\s+/g, ' ')
        .replace(/[“”]/g, '"')
        .replace(/[‘’]/g, "'")
        .trim();
    }

    function tokenizeWords(str) {
      return str.split(' ').filter(Boolean);
    }

    function splitIntoSentences(str) {
      const parts = str.match(/[^.!?]+[.!?]+|[^.!?]+$/g);
      return (parts || []).map(s => s.trim()).filter(Boolean);
    }

    function buildSentenceIndexing(text) {
      const sentences = splitIntoSentences(text);
      const starts = [];
      const map = [];

      let runningWordIndex = 0;
      const allWords = [];

      sentences.forEach((s, si) => {
        const w = tokenizeWords(s);
        if (w.length === 0) return;

        starts.push(runningWordIndex);
        for (let i = 0; i < w.length; i++) {
          map[runningWordIndex + i] = si;
        }

        allWords.push(...w);
        runningWordIndex += w.length;
      });

      if (allWords.length === 0) {
        const fallback = tokenizeWords(text);
        fallback.forEach((_, wi) => map[wi] = 0);
        return { words: fallback, sentenceStarts: [0], wordToSentence: map };
      }

      return { words: allWords, sentenceStarts: starts, wordToSentence: map };
    }

    function getOrpIndex(word) {
      const len = word.length;
      const lettersOnly = word.replace(/[^A-Za-z0-9ÅÆØåæø]/g, '');
      if (!lettersOnly) return Math.min(0, len - 1);

      let orp = Math.round(len * 0.35);
      if (len <= 1) orp = 0;
      else if (len === 2) orp = 0;
      else orp = Math.max(1, Math.min(len - 2, orp));

      return orp;
    }

    function splitForDisplay(word) {
      const orp = getOrpIndex(word);
      return {
        left: word.slice(0, orp),
        center: word[orp] ?? '',
        right: word.slice(orp + 1),
      };
    }

    function showWord(word) {
      const parts = splitForDisplay(word);
      leftPart.textContent = parts.left;
      centerPart.textContent = parts.center;
      rightPart.textContent = parts.right;
    }

    function msPerWord(wpm) { return 60000 / wpm; }

    function extraDelay(word) {
      if (/[.!?]$/.test(word)) return 220;
      if (/[,;:]$/.test(word)) return 120;
      if (word.length >= 10) return 80;
      return 0;
    }

    // -------------------------
    // Progress bar
    // -------------------------
    function updateProgressBar() {
      const total = Math.max(1, words.length);
      const p = Math.max(0, Math.min(1, idx / total));
      progressFill.style.width = (p * 100).toFixed(2) + "%";
    }

    // -------------------------
    // Persist progress
    // -------------------------
    function persistProgressIfPossible(force=false) {
      if (!currentDocName) return;
      if (!words.length) return;
      if (!force && idx === lastPersistedIdx) return;

      const map = loadSavedTexts();
      const entry = map[currentDocName];
      if (!entry) return;

      if ((entry.text || "") !== currentDocText) return;

      entry.progressWordIndex = Math.max(0, Math.min(words.length - 1, idx));
      entry.updatedAt = Date.now();
      map[currentDocName] = entry;

      saveSavedTexts(map);
      lastPersistedIdx = idx;
      updateResumeHint();
    }

    function updateResumeHint() {
      const map = loadSavedTexts();
      if (!currentDocName || !map[currentDocName]) {
        resumeHint.textContent = "No saved progress loaded.";
        return;
      }
      const e = map[currentDocName];
      const totalWords = tokenizeWords(normalizeText(e.text || "")).length || 1;
      const prog = Math.max(0, Math.min(totalWords, e.progressWordIndex || 0));
      const pct = Math.round((prog / totalWords) * 100);
      resumeHint.textContent = `Loaded: "${currentDocName}" • Resume at ${pct}%`;
    }

    // -------------------------
    // Playback
    // -------------------------
    function step() {
      if (!isPlaying) return;
      if (idx >= words.length) {
        pause();
        return;
      }

      const w = words[idx++];
      showWord(w);

      updateProgressBar();
      persistProgressIfPossible(false);

      const delay = msPerWord(selectedWpm) + extraDelay(w);
      clearTimeout(timer);
      timer = setTimeout(step, delay);
    }

    function play() {
      if (words.length === 0) return;
      isPlaying = true;
      step();
    }

    function pause() {
      isPlaying = false;
      clearTimeout(timer);
      timer = null;
      persistProgressIfPossible(true);
    }

    function togglePlayPause() {
      if (!overlay.classList.contains('show')) return;
      if (isPlaying) pause();
      else play();
    }

    function enterReadingMode() {
      overlay.classList.add('show');
      document.body.style.overflow = 'hidden';
    }

    function exitReadingMode() {
      pause();
      overlay.classList.remove('show');
      document.body.style.overflow = '';
    }

    // -------------------------
    // Sentence navigation (ONLY when paused)
    // -------------------------
    function getCurrentSentenceIndex() {
      const at = Math.max(0, Math.min(words.length - 1, Math.max(0, idx - 1)));
      return wordToSentence[at] ?? 0;
    }

    function jumpToSentence(sentenceIndex) {
      if (!sentenceStarts.length) return;
      const s = Math.max(0, Math.min(sentenceStarts.length - 1, sentenceIndex));
      idx = sentenceStarts[s];

      idx = Math.max(0, Math.min(words.length - 1, idx));
      showWord(words[idx] || "");
      updateProgressBar();
      persistProgressIfPossible(true);
    }

    function nextSentence() {
      const s = getCurrentSentenceIndex();
      jumpToSentence(s + 1);
    }

    function prevSentence() {
      const s = getCurrentSentenceIndex();
      jumpToSentence(s - 1);
    }

    // -------------------------
    // Robust tap vs swipe:
    // - Swipe ONLY works when paused
    // - Taps always toggle pause/resume
    // -------------------------
    let touchStartX = 0, touchStartY = 0, touchStartT = 0;

    tapCatcher.addEventListener('touchstart', (e) => {
      const t = e.changedTouches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;
      touchStartT = performance.now();
    }, { passive: true });

    tapCatcher.addEventListener('touchend', (e) => {
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      const dt = performance.now() - touchStartT;

      const absX = Math.abs(dx);
      const absY = Math.abs(dy);

      const isSwipe = (absX > 55 && absY < 35 && dt < 550);

      // SWIPE ONLY WHEN PAUSED
      if (!isPlaying && isSwipe) {
        if (dx < 0) nextSentence();
        else prevSentence();
        return;
      }

      // Otherwise always treat as TAP toggle (stable)
      togglePlayPause();
    }, { passive: true });

    // Desktop click toggles
    tapCatcher.addEventListener('click', () => {
      togglePlayPause();
    });

    // -------------------------
    // Save/Load/Delete/Restart
    // -------------------------
    saveBtn.addEventListener('click', () => {
      const name = (saveName.value || "").trim();
      const text = normalizeText(textInput.value || "");

      if (!name) { alert("Give it a name first."); return; }
      if (!text) { alert("Nothing to save — paste some text first."); return; }

      const map = loadSavedTexts();
      const prev = map[name];

      let progressWordIndex = 0;
      if (prev && (prev.text || "") === text) progressWordIndex = prev.progressWordIndex || 0;

      map[name] = { text, progressWordIndex, updatedAt: Date.now() };
      saveSavedTexts(map);

      currentDocName = name;
      currentDocText = text;

      refreshSavedDropdown();
      savedSelect.value = name;
      updateResumeHint();

      alert("Saved ✅");
    });

    loadBtn.addEventListener('click', () => {
      const name = savedSelect.value;
      if (!name) { alert("Pick a saved item to load."); return; }

      const map = loadSavedTexts();
      const entry = map[name];
      if (!entry) { alert("That saved text is missing."); refreshSavedDropdown(); return; }

      currentDocName = name;
      currentDocText = normalizeText(entry.text || "");
      textInput.value = currentDocText;

      updateResumeHint();
    });

    deleteBtn.addEventListener('click', () => {
      const name = savedSelect.value;
      if (!name) { alert("Pick a saved item to delete."); return; }
      if (!confirm(`Delete "${name}"?`)) return;

      const map = loadSavedTexts();
      delete map[name];
      saveSavedTexts(map);

      if (currentDocName === name) {
        currentDocName = "";
        currentDocText = "";
      }

      refreshSavedDropdown();
      updateResumeHint();
      textInput.focus();
    });

    restartBtn.addEventListener('click', () => {
      if (!currentDocName) {
        alert("Load a saved text to restart its progress.");
        return;
      }
      const map = loadSavedTexts();
      const entry = map[currentDocName];
      if (!entry) return;

      entry.progressWordIndex = 0;
      entry.updatedAt = Date.now();
      map[currentDocName] = entry;
      saveSavedTexts(map);

      updateResumeHint();
      alert("Progress reset ✅");
    });

    clearBtn.addEventListener('click', () => {
      textInput.value = "";
      currentDocName = "";
      currentDocText = "";
      updateResumeHint();
      textInput.focus();
    });

    // -------------------------
    // Start Reading (auto resume)
    // -------------------------
    startBtn.addEventListener('click', () => {
      const raw = normalizeText(textInput.value || "");
      if (!raw) { alert("Paste some text first."); return; }

      const built = buildSentenceIndexing(raw);
      words = built.words;
      sentenceStarts = built.sentenceStarts;
      wordToSentence = built.wordToSentence;

      idx = 0;

      if (currentDocName) {
        const map = loadSavedTexts();
        const entry = map[currentDocName];
        if (entry && normalizeText(entry.text || "") === raw) {
          currentDocText = raw;
          idx = Math.max(0, Math.min(words.length - 1, entry.progressWordIndex || 0));
        } else {
          currentDocText = raw;
          idx = 0;
        }
      } else {
        currentDocText = raw;
      }

      lastPersistedIdx = -1;

      enterReadingMode();
      showWord(words[idx] || "");
      updateProgressBar();
      play();
    });

    exitBtn.addEventListener('click', () => {
      exitReadingMode();
    });

    // -------------------------
    // PDF loading
    // -------------------------
    pdfBtn.addEventListener('click', () => {
      pdfInput.value = "";
      pdfInput.click();
    });

    async function extractPdfText(file) {
      // PDF.js expects a Uint8Array
      const buf = await file.arrayBuffer();
      const uint8 = new Uint8Array(buf);

      // Standard worker setup (PDF.js 4+)
      // If it warns, it still usually works fine via cdnjs.
      const loadingTask = pdfjsLib.getDocument({ data: uint8 });
      const pdf = await loadingTask.promise;

      let full = [];
      for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();
        const strings = content.items.map(it => it.str).filter(Boolean);
        full.push(strings.join(" "));
      }
      return normalizeText(full.join("\n\n"));
    }

    pdfInput.addEventListener('change', async () => {
      const file = pdfInput.files && pdfInput.files[0];
      if (!file) return;

      pdfStatus.textContent = "Loading PDF…";
      try {
        const text = await extractPdfText(file);
        if (!text) {
          pdfStatus.textContent = "PDF loaded, but no text found (maybe scanned image).";
          return;
        }
        textInput.value = text;
        pdfStatus.textContent = `PDF loaded ✅ (${Math.round(text.length/1000)}k chars)`;
      } catch (err) {
        console.error(err);
        pdfStatus.textContent = "Failed to load PDF ❌";
        alert("Could not extract text from that PDF.");
      }
    });

    // -------------------------
    // Init
    // -------------------------
    applyPrefs();
    refreshSavedDropdown();
    updateResumeHint();

    // Keep currentDocName updated when selecting
    savedSelect.addEventListener('change', () => {
      const name = savedSelect.value;
      if (!name) return;
      const map = loadSavedTexts();
      const entry = map[name];
      if (!entry) return;

      currentDocName = name;
      currentDocText = normalizeText(entry.text || "");
      updateResumeHint();
    });
  </script>
</body>
</html>
