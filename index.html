<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#000000" />
  <title>RSVP Speed Reader</title>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.js"></script>
  <!-- Tesseract OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --accent:#ff3b30;
      --muted:#a0a0a0;
      --card:#111;
      --border:#222;
      --btn:#1c1c1e;
      --btn2:#2c2c2e;
      --rsvpScale: 1.0; /* 20%..200% => 0.2..2.0 */
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{
      margin:0; height:100%; background:var(--bg); color:var(--fg);
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    /* Red sliders on iOS */
    input[type="range"]{ accent-color: var(--accent); }

    .app{
      min-height:100%;
      padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom) 16px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    header{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      padding-top:10px;
    }

    .title{ font-weight:950; letter-spacing:0.2px; font-size:20px; }
    .subtitle{ color:var(--muted); font-size:12px; margin-top:4px; }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
    }

    .hint{ color:var(--muted); font-size:12px; line-height:1.35; }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    button{
      border:none;
      border-radius:14px;
      padding:14px 14px;
      font-size:16px;
      font-weight:950;
      background:var(--btn2);
      color:var(--fg);
    }
    .primary{ background:var(--accent); color:#000; }

    .miniBtn{
      padding:10px 12px;
      border-radius:12px;
      background:var(--btn);
      border:1px solid var(--border);
      font-weight:950;
      font-size:14px;
    }

    input, select{
      background:#050505;
      color:var(--fg);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
      outline:none;
      flex:1;
      min-width: 160px;
    }

    textarea{
      width:100%;
      min-height:170px;
      resize:none;
      border-radius:12px;
      border:1px solid var(--border);
      background:#050505;
      color:var(--fg);
      padding:12px;
      font-size:15px;
      line-height:1.35;
      outline:none;
    }
    textarea::placeholder{ color:#666; }

    .actions{ display:flex; gap:10px; }

    .sliderWrap{
      display:flex;
      align-items:center;
      gap:12px;
      margin-top:10px;
    }
    .sliderWrap label{ font-weight:950; min-width:70px; }

    .pill{
      padding:6px 10px;
      border-radius:999px;
      background:#0b0b0b;
      border:1px solid var(--border);
      font-size:12px;
      color:var(--muted);
      font-weight:950;
      min-width:72px;
      text-align:center;
    }

    .resumeNote{
      margin-top:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    /* Reading overlay (clean) */
    .overlay{
      position:fixed;
      inset:0;
      background:#000;
      display:none;
      align-items:center;
      justify-content:center;
      padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom) 16px;
      z-index:9999;
    }
    .overlay.show{ display:flex; }

    .tapCatcher{
      position:absolute;
      inset:0;
      background:transparent;
    }

    .topBar{
      position:absolute;
      top: env(safe-area-inset-top);
      left:0; right:0;
      padding: 10px 16px 8px 16px;
      display:flex;
      justify-content:flex-end;
      pointer-events:none;
    }
    .topBar > *{ pointer-events:auto; }

    .smallBtn{
      padding:10px 12px;
      border-radius:12px;
      background:rgba(28,28,30,0.75);
      border:1px solid rgba(34,34,34,0.9);
      font-weight:950;
      font-size:14px;
      color:var(--fg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .overlayInner{
      width:100%;
      max-width:680px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      user-select:none;
    }

    .wordBox{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:180px;
      padding: 0 6px;
    }

    .word{
      font-weight:950;
      font-size: calc(clamp(44px, 8vw, 90px) * var(--rsvpScale));
      letter-spacing: 0.5px;
      line-height:1;
      display:flex;
      align-items:baseline;
      justify-content:center;
      font-variant-ligatures:none;
      text-align:center;
    }

    .left, .right{
      display:inline-block;
      min-width: 2ch;
      text-align:right;
      color:var(--fg);
      opacity:0.96;
    }
    .right{ text-align:left; }

    .center{
      color:var(--accent);
      padding:0 2px;
      text-shadow: 0 0 10px rgba(255,59,48,0.12);
    }

    /* Bottom progress bar */
    .progressWrap{
      position:absolute;
      left:0; right:0;
      bottom: env(safe-area-inset-bottom);
      padding: 0 16px 10px 16px;
      pointer-events:none;
    }
    .progressBar{
      height:4px;
      border-radius:999px;
      background:#222;
      overflow:hidden;
    }
    .progressFill{
      height:100%;
      width:0%;
      background:#666;
      border-radius:999px;
      transition: width 90ms linear;
    }
  </style>
</head>

<body>
  <div class="app" id="home">
    <header>
      <div>
        <div class="title">RSVP Speed Reader</div>
        <div class="subtitle">Tap to pause • Swipe sentence when paused</div>
      </div>
    </header>

    <div class="card">
      <div style="font-weight:950; margin-bottom:10px;">Speed</div>

      <div class="sliderWrap">
        <label for="wpmSlider">WPM</label>
        <input type="range" id="wpmSlider" min="100" max="900" step="100" value="300" />
        <div class="pill" id="wpmLabel">300</div>
      </div>

      <div class="sliderWrap" style="margin-top:14px;">
        <label for="sizeSlider">Size</label>
        <input type="range" id="sizeSlider" min="0.2" max="2.0" step="0.05" value="1.0" />
        <div class="pill" id="sizeLabel">100%</div>
      </div>
    </div>

    <div class="card">
      <div style="font-weight:950; margin-bottom:10px;">Text</div>

      <div class="row" style="margin-bottom:10px;">
        <button class="miniBtn" id="pdfBtn">Load PDF</button>
        <div class="hint" id="pdfStatus" style="flex:1;">PDF text will be inserted below.</div>
      </div>
      <input id="pdfInput" type="file" accept="application/pdf" style="display:none;" />

      <div class="row" style="margin-bottom:10px;">
        <input id="saveName" placeholder="Name (e.g. Article 1)" />
        <button class="miniBtn" id="saveBtn">Save</button>
      </div>

      <div class="row" style="margin-bottom:10px;">
        <select id="savedSelect">
          <option value="">Load saved text…</option>
        </select>
        <button class="miniBtn" id="loadBtn">Load</button>
        <button class="miniBtn" id="deleteBtn">Delete</button>
      </div>

      <textarea id="textInput" placeholder="Paste or type your text here..."></textarea>

      <div class="resumeNote">
        <div class="hint" id="resumeHint">No saved progress loaded.</div>
        <button class="miniBtn" id="restartBtn">Restart</button>
      </div>

      <div class="hint" style="margin-top:10px;">
        iPhone: Safari → Share → <b>Add to Home Screen</b>
      </div>
    </div>

    <div class="actions">
      <button class="primary" id="startBtn" style="flex:1;">Start Reading</button>
      <button id="clearBtn">Clear</button>
    </div>
  </div>

  <!-- Reading overlay -->
  <div class="overlay" id="overlay">
    <div class="tapCatcher" id="tapCatcher"></div>

    <div class="topBar">
      <button class="smallBtn" id="exitBtn">Exit</button>
    </div>

    <div class="overlayInner">
      <div class="wordBox">
        <div class="word" aria-live="polite" aria-atomic="true">
          <span class="left" id="leftPart"></span>
          <span class="center" id="centerPart"></span>
          <span class="right" id="rightPart"></span>
        </div>
      </div>
    </div>

    <div class="progressWrap">
      <div class="progressBar">
        <div class="progressFill" id="progressFill"></div>
      </div>
    </div>
  </div>

  <script>
    // ---- PDF.js worker fix (CRITICAL) ----
    // Without this, Safari/GitHub Pages often fails to load PDFs.
    try {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.js";
    } catch (e) {
      // ignore
    }

    // -------------------------
    // LocalStorage keys
    // -------------------------
    const STORE_KEY_TEXTS = "rsvp_saved_texts_v5";
    const STORE_KEY_PREFS = "rsvp_prefs_v4";

    // -------------------------
    // State
    // -------------------------
    let selectedWpm = 300;

    let currentDocName = "";
    let currentDocText = "";
    let lastPersistedIdx = -1;

    let words = [];
    let idx = 0;
    let timer = null;
    let isPlaying = false;

    let sentenceStarts = [];
    let wordToSentence = [];

    // -------------------------
    // DOM refs
    // -------------------------
    const wpmSlider = document.getElementById('wpmSlider');
    const wpmLabel  = document.getElementById('wpmLabel');

    const sizeSlider = document.getElementById('sizeSlider');
    const sizeLabel = document.getElementById('sizeLabel');

    const pdfBtn = document.getElementById('pdfBtn');
    const pdfInput = document.getElementById('pdfInput');
    const pdfStatus = document.getElementById('pdfStatus');

    const saveName = document.getElementById('saveName');
    const saveBtn = document.getElementById('saveBtn');
    const savedSelect = document.getElementById('savedSelect');
    const loadBtn = document.getElementById('loadBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const restartBtn = document.getElementById('restartBtn');

    const resumeHint = document.getElementById('resumeHint');

    const textInput = document.getElementById('textInput');
    const startBtn = document.getElementById('startBtn');
    const clearBtn = document.getElementById('clearBtn');

    const overlay = document.getElementById('overlay');
    const exitBtn = document.getElementById('exitBtn');
    const tapCatcher = document.getElementById('tapCatcher');

    const leftPart = document.getElementById('leftPart');
    const centerPart = document.getElementById('centerPart');
    const rightPart = document.getElementById('rightPart');

    const progressFill = document.getElementById('progressFill');

    // -------------------------
    // Storage helpers
    // -------------------------
    function loadSavedTexts() {
      try { return JSON.parse(localStorage.getItem(STORE_KEY_TEXTS) || "{}"); }
      catch { return {}; }
    }
    function saveSavedTexts(map) {
      localStorage.setItem(STORE_KEY_TEXTS, JSON.stringify(map));
    }
    function refreshSavedDropdown() {
      const map = loadSavedTexts();
      const current = savedSelect.value;

      savedSelect.innerHTML = '<option value="">Load saved text…</option>';
      Object.keys(map).sort((a,b)=>a.localeCompare(b)).forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        savedSelect.appendChild(opt);
      });

      if (current && map[current]) savedSelect.value = current;
    }

    // -------------------------
    // Prefs
    // -------------------------
    function loadPrefs() {
      try { return JSON.parse(localStorage.getItem(STORE_KEY_PREFS) || "{}"); }
      catch { return {}; }
    }
    function savePrefs() {
      localStorage.setItem(STORE_KEY_PREFS, JSON.stringify({
        wpm: selectedWpm,
        scale: parseFloat(sizeSlider.value)
      }));
    }
    function applyPrefs() {
      const prefs = loadPrefs();
      if (prefs.wpm) {
        const w = Math.max(100, Math.min(900, Math.round(prefs.wpm / 100) * 100));
        selectedWpm = w;
        wpmSlider.value = String(w);
        wpmLabel.textContent = String(w);
      } else {
        selectedWpm = parseInt(wpmSlider.value, 10);
        wpmLabel.textContent = String(selectedWpm);
      }

      if (prefs.scale) {
        const s = Math.max(0.2, Math.min(2.0, prefs.scale));
        sizeSlider.value = s;
        setRsvpScale(s);
      } else {
        setRsvpScale(parseFloat(sizeSlider.value));
      }
    }

    // -------------------------
    // Sliders
    // -------------------------
    wpmSlider.addEventListener('input', () => {
      selectedWpm = parseInt(wpmSlider.value, 10);
      wpmLabel.textContent = String(selectedWpm);
      savePrefs();
    });

    function setRsvpScale(scale) {
      document.documentElement.style.setProperty('--rsvpScale', String(scale));
      sizeLabel.textContent = Math.round(scale * 100) + "%";
    }
    sizeSlider.addEventListener('input', () => {
      setRsvpScale(parseFloat(sizeSlider.value));
      savePrefs();
    });

    // -------------------------
    // Text utilities
    // -------------------------
    function normalizeText(str) {
      return (str || "")
        .replace(/\s+/g, ' ')
        .replace(/[“”]/g, '"')
        .replace(/[‘’]/g, "'")
        .trim();
    }

    function tokenizeWords(str) {
      return str.split(' ').filter(Boolean);
    }

    function splitIntoSentences(str) {
      const parts = str.match(/[^.!?]+[.!?]+|[^.!?]+$/g);
      return (parts || []).map(s => s.trim()).filter(Boolean);
    }

    function buildSentenceIndexing(text) {
      const sentences = splitIntoSentences(text);
      const starts = [];
      const map = [];

      let runningWordIndex = 0;
      const allWords = [];

      sentences.forEach((s, si) => {
        const w = tokenizeWords(s);
        if (w.length === 0) return;

        starts.push(runningWordIndex);
        for (let i = 0; i < w.length; i++) map[runningWordIndex + i] = si;

        allWords.push(...w);
        runningWordIndex += w.length;
      });

      if (allWords.length === 0) {
        const fallback = tokenizeWords(text);
        fallback.forEach((_, wi) => map[wi] = 0);
        return { words: fallback, sentenceStarts: [0], wordToSentence: map };
      }
      return { words: allWords, sentenceStarts: starts, wordToSentence: map };
    }

    function getOrpIndex(word) {
      const len = word.length;
      const lettersOnly = word.replace(/[^A-Za-z0-9ÅÆØåæø]/g, '');
      if (!lettersOnly) return Math.min(0, len - 1);

      let orp = Math.round(len * 0.35);
      if (len <= 1) orp = 0;
      else if (len === 2) orp = 0;
      else orp = Math.max(1, Math.min(len - 2, orp));
      return orp;
    }

    function splitForDisplay(word) {
      const orp = getOrpIndex(word || "");
      return {
        left: (word || "").slice(0, orp),
        center: (word || "")[orp] ?? '',
        right: (word || "").slice(orp + 1),
      };
    }

    function showWord(word) {
      const p = splitForDisplay(word || "");
      leftPart.textContent = p.left;
      centerPart.textContent = p.center;
      rightPart.textContent = p.right;
    }

    function msPerWord(wpm) { return 60000 / wpm; }
    function extraDelay(word) {
      if (/[.!?]$/.test(word)) return 220;
      if (/[,;:]$/.test(word)) return 120;
      if ((word || "").length >= 10) return 80;
      return 0;
    }

    // -------------------------
    // Progress bar
    // -------------------------
    function updateProgressBar() {
      const total = Math.max(1, words.length);
      const p = Math.max(0, Math.min(1, idx / total));
      progressFill.style.width = (p * 100).toFixed(2) + "%";
    }

    // -------------------------
    // Persist progress
    // -------------------------
    function persistProgressIfPossible(force=false) {
      if (!currentDocName) return;
      if (!words.length) return;
      if (!force && idx === lastPersistedIdx) return;

      const map = loadSavedTexts();
      const entry = map[currentDocName];
      if (!entry) return;
      if ((entry.text || "") !== currentDocText) return;

      entry.progressWordIndex = Math.max(0, Math.min(words.length - 1, idx));
      entry.updatedAt = Date.now();
      map[currentDocName] = entry;

      saveSavedTexts(map);
      lastPersistedIdx = idx;
      updateResumeHint();
    }

    function updateResumeHint() {
      const map = loadSavedTexts();
      if (!currentDocName || !map[currentDocName]) {
        resumeHint.textContent = "No saved progress loaded.";
        return;
      }
      const e = map[currentDocName];
      const totalWords = tokenizeWords(normalizeText(e.text || "")).length || 1;
      const prog = Math.max(0, Math.min(totalWords, e.progressWordIndex || 0));
      const pct = Math.round((prog / totalWords) * 100);
      resumeHint.textContent = `Loaded: "${currentDocName}" • Resume at ${pct}%`;
    }

    // -------------------------
    // Playback
    // -------------------------
    function step() {
      if (!isPlaying) return;
      if (idx >= words.length) { pause(); return; }

      const w = words[idx++];
      showWord(w);

      updateProgressBar();
      persistProgressIfPossible(false);

      const delay = msPerWord(selectedWpm) + extraDelay(w);
      clearTimeout(timer);
      timer = setTimeout(step, delay);
    }

    function play() { if (!words.length) return; isPlaying = true; step(); }
    function pause() {
      isPlaying = false;
      clearTimeout(timer);
      timer = null;
      persistProgressIfPossible(true);
    }

    function togglePlayPause() {
      if (!overlay.classList.contains('show')) return;
      if (isPlaying) pause(); else play();
    }

    function enterReadingMode() { overlay.classList.add('show'); document.body.style.overflow='hidden'; }
    function exitReadingMode() { pause(); overlay.classList.remove('show'); document.body.style.overflow=''; }

    // -------------------------
    // Sentence navigation (ONLY when paused)
    // -------------------------
    function getCurrentSentenceIndex() {
      const at = Math.max(0, Math.min(words.length - 1, Math.max(0, idx - 1)));
      return wordToSentence[at] ?? 0;
    }

    function jumpToSentence(sentenceIndex) {
      if (!sentenceStarts.length) return;
      const s = Math.max(0, Math.min(sentenceStarts.length - 1, sentenceIndex));
      idx = sentenceStarts[s];
      idx = Math.max(0, Math.min(words.length - 1, idx));
      showWord(words[idx] || "");
      updateProgressBar();
      persistProgressIfPossible(true);
    }

    function nextSentence() { jumpToSentence(getCurrentSentenceIndex() + 1); }
    function prevSentence() { jumpToSentence(getCurrentSentenceIndex() - 1); }

    // Tap always toggles, swipe only when paused
    let touchStartX=0, touchStartY=0, touchStartT=0;
    tapCatcher.addEventListener('touchstart', (e)=>{
      const t=e.changedTouches[0];
      touchStartX=t.clientX; touchStartY=t.clientY; touchStartT=performance.now();
    }, {passive:true});

    tapCatcher.addEventListener('touchend', (e)=>{
      const t=e.changedTouches[0];
      const dx=t.clientX-touchStartX;
      const dy=t.clientY-touchStartY;
      const dt=performance.now()-touchStartT;

      const absX=Math.abs(dx), absY=Math.abs(dy);
      const isSwipe=(absX>60 && absY<35 && dt<650);

      if (!isPlaying && isSwipe) {
        if (dx < 0) nextSentence(); else prevSentence();
        return;
      }
      togglePlayPause();
    }, {passive:true});

    tapCatcher.addEventListener('click', ()=>togglePlayPause());

    // -------------------------
    // Save/Load/Delete/Restart
    // -------------------------
    saveBtn.addEventListener('click', ()=>{
      const name=(saveName.value||"").trim();
      const text=normalizeText(textInput.value||"");
      if(!name){alert("Give it a name first.");return;}
      if(!text){alert("Nothing to save — paste some text first.");return;}

      const map=loadSavedTexts();
      const prev=map[name];
      let progressWordIndex=0;
      if(prev && (prev.text||"")===text) progressWordIndex=prev.progressWordIndex||0;

      map[name]={text, progressWordIndex, updatedAt:Date.now()};
      saveSavedTexts(map);

      currentDocName=name;
      currentDocText=text;

      refreshSavedDropdown();
      savedSelect.value=name;
      updateResumeHint();
      alert("Saved ✅");
    });

    loadBtn.addEventListener('click', ()=>{
      const name=savedSelect.value;
      if(!name){alert("Pick a saved item to load.");return;}
      const map=loadSavedTexts();
      const entry=map[name];
      if(!entry){alert("That saved text is missing.");refreshSavedDropdown();return;}

      currentDocName=name;
      currentDocText=normalizeText(entry.text||"");
      textInput.value=currentDocText;
      updateResumeHint();
    });

    deleteBtn.addEventListener('click', ()=>{
      const name=savedSelect.value;
      if(!name){alert("Pick a saved item to delete.");return;}
      if(!confirm(`Delete "${name}"?`)) return;

      const map=loadSavedTexts();
      delete map[name];
      saveSavedTexts(map);

      if(currentDocName===name){currentDocName="";currentDocText="";}
      refreshSavedDropdown();
      updateResumeHint();
    });

    restartBtn.addEventListener('click', ()=>{
      if(!currentDocName){alert("Load a saved text to restart its progress.");return;}
      const map=loadSavedTexts();
      const entry=map[currentDocName];
      if(!entry) return;

      entry.progressWordIndex=0;
      entry.updatedAt=Date.now();
      map[currentDocName]=entry;
      saveSavedTexts(map);
      updateResumeHint();
      alert("Progress reset ✅");
    });

    clearBtn.addEventListener('click', ()=>{
      textInput.value="";
      currentDocName="";
      currentDocText="";
      updateResumeHint();
    });

    // -------------------------
    // Start reading (auto resume)
    // -------------------------
    startBtn.addEventListener('click', ()=>{
      const raw=normalizeText(textInput.value||"");
      if(!raw){alert("Paste some text first.");return;}

      const built=buildSentenceIndexing(raw);
      words=built.words;
      sentenceStarts=built.sentenceStarts;
      wordToSentence=built.wordToSentence;

      idx=0;

      if(currentDocName){
        const map=loadSavedTexts();
        const entry=map[currentDocName];
        if(entry && normalizeText(entry.text||"")===raw){
          currentDocText=raw;
          idx=Math.max(0, Math.min(words.length-1, entry.progressWordIndex||0));
        } else {
          currentDocText=raw;
          idx=0;
        }
      } else {
        currentDocText=raw;
      }

      lastPersistedIdx=-1;

      enterReadingMode();
      showWord(words[idx]||"");
      updateProgressBar();
      play();
    });

    exitBtn.addEventListener('click', ()=>exitReadingMode());

    // -------------------------
    // PDF import (fixed + robust)
    // -------------------------
    pdfBtn.addEventListener('click', ()=>{
      pdfInput.value="";
      pdfInput.click();
    });

    async function renderPageToCanvas(page, scale=2.1){
      const viewport = page.getViewport({ scale });
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d", { willReadFrequently:true });
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      await page.render({ canvasContext:ctx, viewport }).promise;
      return canvas;
    }

    function cleanOcrText(t){
      return normalizeText(
        (t||"")
          .replace(/-\s+/g, "")
          .replace(/\n{3,}/g, "\n\n")
          .replace(/[ \t]{2,}/g, " ")
      );
    }

    async function openPdfDocument(uint8) {
      // First attempt: normal worker mode
      try {
        const loadingTask = pdfjsLib.getDocument({ data:uint8 });
        return await loadingTask.promise;
      } catch (e) {
        // Fallback: disableWorker (more compatible on iOS / homescreen)
        const loadingTask = pdfjsLib.getDocument({ data:uint8, disableWorker:true });
        return await loadingTask.promise;
      }
    }

    async function extractPdfSmartAuto(file){
      const buf = await file.arrayBuffer();
      const uint8 = new Uint8Array(buf);

      pdfStatus.textContent = "Opening PDF…";
      const pdf = await openPdfDocument(uint8);

      const pageCount = pdf.numPages;

      // Create ONE OCR worker
      const worker = await Tesseract.createWorker("eng");

      // OCR only when needed, cap OCR pages automatically for iPhone safety
      const OCR_TEXT_THRESHOLD = 60; // chars/page
      const MAX_OCR_PAGES = 35;
      let ocrUsed = 0;

      const out = [];

      try{
        for(let p=1; p<=pageCount; p++){
          pdfStatus.textContent = `Reading PDF… Page ${p}/${pageCount}`;
          const page = await pdf.getPage(p);

          // Fast text extraction per page
          let fastText = "";
          try{
            const content = await page.getTextContent();
            const strings = content.items.map(it => (it.str||"").trim()).filter(Boolean);
            fastText = strings.join(" ");
          } catch { fastText = ""; }

          const fastLen = normalizeText(fastText).length;
          const shouldOcr = fastLen < OCR_TEXT_THRESHOLD;

          if(!shouldOcr){
            out.push(normalizeText(fastText));
            continue;
          }

          if(ocrUsed >= MAX_OCR_PAGES){
            out.push(normalizeText(fastText));
            continue;
          }

          ocrUsed++;
          pdfStatus.textContent = `OCR… Page ${p}/${pageCount}`;
          const canvas = await renderPageToCanvas(page, 2.2);
          const { data } = await worker.recognize(canvas);
          const ocrText = cleanOcrText(data?.text || "");
          out.push(ocrText || normalizeText(fastText));
        }
      } finally {
        await worker.terminate();
      }

      return { text: normalizeText(out.filter(Boolean).join("\n\n")), pages:pageCount, ocrPages:ocrUsed };
    }

    pdfInput.addEventListener('change', async ()=>{
      const file = pdfInput.files && pdfInput.files[0];
      if(!file) return;

      pdfStatus.textContent = "Loading PDF…";

      try{
        const res = await extractPdfSmartAuto(file);
        if(!res.text){
          pdfStatus.textContent = "PDF loaded, but no readable text found.";
          alert("No readable text found.");
          return;
        }
        textInput.value = res.text;
        const k = Math.round(res.text.length/1000);
        pdfStatus.textContent = res.ocrPages > 0
          ? `PDF loaded ✅ (${res.pages} pages, OCR ${res.ocrPages}p, ~${k}k chars)`
          : `PDF loaded ✅ (${res.pages} pages, ~${k}k chars)`;
      } catch(err){
        console.error(err);
        pdfStatus.textContent = "Failed to load PDF ❌";
        alert("PDF load failed. (Worker / Safari issue fixed in this version—if it still fails, send the console error.)");
      }
    });

    // -------------------------
    // Init
    // -------------------------
    applyPrefs();
    refreshSavedDropdown();
    updateResumeHint();

    savedSelect.addEventListener('change', ()=>{
      const name=savedSelect.value;
      if(!name) return;
      const map=loadSavedTexts();
      const entry=map[name];
      if(!entry) return;
      currentDocName=name;
      currentDocText=normalizeText(entry.text||"");
      updateResumeHint();
    });
  </script>
</body>
</html>
