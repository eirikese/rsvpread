<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#000000" />
  <title>RSVP Speed Reader</title>

  <!-- ✅ iPhone-friendly PDF approach -->
  <script src="https://unpkg.com/pdfjs-dist@2.16.105/legacy/build/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --accent:#ff3b30;

      --muted:#a0a0a0;
      --card:#111;
      --border:#222;
      --btn:#1c1c1e;
      --btn2:#2c2c2e;

      --rsvpScale: 1.0; /* 0.2..2.0 => 20..200% */
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{
      margin:0; height:100%; background:var(--bg); color:var(--fg);
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    input[type="range"]{ accent-color: var(--accent); }

    .app{
      min-height:100%;
      padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom) 16px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    header{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      padding-top:10px;
    }

    .title{ font-weight:950; letter-spacing:0.2px; font-size:20px; }
    .subtitle{ color:var(--muted); font-size:12px; margin-top:4px; }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
    }

    .hint{ color:var(--muted); font-size:12px; line-height:1.35; }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    button{
      border:none;
      border-radius:14px;
      padding:14px 14px;
      font-size:16px;
      font-weight:950;
      background:var(--btn2);
      color:var(--fg);
    }
    .primary{ background:var(--accent); color:#000; }

    .miniBtn{
      padding:10px 12px;
      border-radius:12px;
      background:var(--btn);
      border:1px solid var(--border);
      font-weight:950;
      font-size:14px;
    }

    input, select{
      background:#050505;
      color:var(--fg);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
      outline:none;
      flex:1;
      min-width: 160px;
    }

    textarea{
      width:100%;
      min-height:170px;
      resize:none;
      border-radius:12px;
      border:1px solid var(--border);
      background:#050505;
      color:var(--fg);
      padding:12px;
      font-size:15px;
      line-height:1.35;
      outline:none;
    }
    textarea::placeholder{ color:#666; }

    .actions{ display:flex; gap:10px; }

    .sliderWrap{
      display:flex;
      align-items:center;
      gap:12px;
      margin-top:10px;
    }
    .sliderWrap label{ font-weight:950; min-width:70px; }

    .pill{
      padding:6px 10px;
      border-radius:999px;
      background:#0b0b0b;
      border:1px solid var(--border);
      font-size:12px;
      color:var(--muted);
      font-weight:950;
      min-width:72px;
      text-align:center;
    }

    .resumeNote{
      margin-top:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    /* -------------------------
       Reading overlay (clean)
       ------------------------- */
    .overlay{
      position:fixed;
      inset:0;
      background:#000;
      display:none;
      align-items:center;
      justify-content:center;
      padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom) 16px;
      z-index:9999;
    }
    .overlay.show{ display:flex; }

    .topBar{
      position:absolute;
      top: env(safe-area-inset-top);
      left:0; right:0;
      padding: 10px 16px 8px 16px;
      display:flex;
      justify-content:flex-end;
      pointer-events:none;
    }
    .topBar > *{ pointer-events:auto; }

    .smallBtn{
      padding:10px 12px;
      border-radius:12px;
      background:rgba(28,28,30,0.55);
      border:1px solid rgba(90,90,90,0.35);
      font-weight:950;
      font-size:14px;
      color:#c8c8c8;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .overlayInner{
      width:100%;
      max-width:720px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      user-select:none;
      padding-bottom: 88px; /* space for bottom controls */
    }

    .wordBox{
      width:100%;
      min-height:220px;
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* Anchor is fixed center of screen */
    .wordAnchor{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%);
      will-change: transform;
      pointer-events:none;
    }

    /* Inner word shifts horizontally based on measured ORP */
    .wordInner{
      display:inline-block;
      font-weight:950;
      font-size: calc(clamp(46px, 8vw, 92px) * var(--rsvpScale));
      letter-spacing: 0px;
      line-height:1;
      white-space:nowrap;
      font-variant-ligatures:none;
      text-rendering: optimizeLegibility;
      will-change: transform;
    }

    .wordInner .center{
      color:var(--accent);
      text-shadow: 0 0 12px rgba(255,59,48,0.14);
    }

    /* Bottom progress bar */
    .progressWrap{
      position:absolute;
      left:0; right:0;
      bottom: calc(env(safe-area-inset-bottom) + 66px);
      padding: 0 16px 8px 16px;
      pointer-events:none;
    }
    .progressBar{
      height:4px;
      border-radius:999px;
      background:#222;
      overflow:hidden;
    }
    .progressFill{
      height:100%;
      width:0%;
      background:#666;
      border-radius:999px;
      transition: width 90ms linear;
    }

    /* Bottom controls */
    .controls{
      position:absolute;
      left:0; right:0;
      bottom: env(safe-area-inset-bottom);
      padding: 10px 16px 12px 16px;
      display:flex;
      justify-content:center;
      align-items:center;
      gap:12px;
    }

    .ctlBtn{
      width:64px;
      height:52px;
      border-radius:14px;
      background:transparent;
      border:1px solid rgba(130,130,130,0.45);
      color:#c8c8c8;
      font-weight:950;
      font-size:20px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .ctlBtn.big{
      width:110px;
      font-size:16px;
      letter-spacing:0.2px;
    }

    .ctlBtn:active{
      transform: scale(0.98);
      border-color: rgba(200,200,200,0.6);
    }

    .ctlBtn[disabled]{
      opacity:0.35;
      transform:none;
    }
  </style>
</head>

<body>
  <div class="app" id="home">
    <header>
      <div>
        <div class="title">RSVP Speed Reader</div>
        <div class="subtitle">Reading uses bottom controls (− Pause +)</div>
      </div>
    </header>

    <div class="card">
      <div style="font-weight:950; margin-bottom:10px;">Speed</div>

      <div class="sliderWrap">
        <label for="wpmSlider">WPM</label>
        <input type="range" id="wpmSlider" min="100" max="900" step="100" value="300" />
        <div class="pill" id="wpmLabel">300</div>
      </div>

      <div class="sliderWrap" style="margin-top:14px;">
        <label for="sizeSlider">Size</label>
        <input type="range" id="sizeSlider" min="0.2" max="2.0" step="0.05" value="1.0" />
        <div class="pill" id="sizeLabel">100%</div>
      </div>
    </div>

    <div class="card">
      <div style="font-weight:950; margin-bottom:10px;">Text</div>

      <div class="row" style="margin-bottom:10px;">
        <button class="miniBtn" id="pdfBtn">Load PDF</button>
        <div class="hint" id="pdfStatus" style="flex:1;">PDF text will be inserted below.</div>
      </div>
      <input id="pdfInput" type="file" accept="application/pdf" style="display:none;" />

      <div class="row" style="margin-bottom:10px;">
        <input id="saveName" placeholder="Name (e.g. Article 1)" />
        <button class="miniBtn" id="saveBtn">Save</button>
      </div>

      <div class="row" style="margin-bottom:10px;">
        <select id="savedSelect">
          <option value="">Load saved text…</option>
        </select>
        <button class="miniBtn" id="loadBtn">Load</button>
        <button class="miniBtn" id="deleteBtn">Delete</button>
      </div>

      <textarea id="textInput" placeholder="Paste or type your text here..."></textarea>

      <div class="resumeNote">
        <div class="hint" id="resumeHint">No saved progress loaded.</div>
        <button class="miniBtn" id="restartBtn">Restart</button>
      </div>

      <div class="hint" style="margin-top:10px;">
        iPhone: Safari → Share → <b>Add to Home Screen</b>
      </div>
    </div>

    <div class="actions">
      <button class="primary" id="startBtn" style="flex:1;">Start Reading</button>
      <button id="clearBtn">Clear</button>
    </div>
  </div>

  <!-- Reading overlay -->
  <div class="overlay" id="overlay">
    <div class="topBar">
      <button class="smallBtn" id="exitBtn">Exit</button>
    </div>

    <div class="overlayInner">
      <div class="wordBox">
        <!-- ✅ Center anchor stays fixed. Word slides left/right to keep ORP locked. -->
        <div class="wordAnchor">
          <div class="wordInner" id="wordInner"></div>
        </div>
      </div>
    </div>

    <div class="progressWrap">
      <div class="progressBar">
        <div class="progressFill" id="progressFill"></div>
      </div>
    </div>

    <div class="controls">
      <button class="ctlBtn" id="backBtn" title="Back sentence">−</button>
      <button class="ctlBtn big" id="pauseBtn" title="Pause/Play">Pause</button>
      <button class="ctlBtn" id="nextBtn" title="Next sentence">+</button>
    </div>
  </div>

  <script>
    /* ==========================
       PDF CONFIG (LEGACY, WORKERLESS)
       ========================== */
    window.pdfjsLib = window['pdfjs-dist/build/pdf'] || window.pdfjsLib;

    /* ==========================
       STORAGE KEYS
       ========================== */
    const STORE_KEY_TEXTS = "rsvp_saved_texts_v8";
    const STORE_KEY_PREFS = "rsvp_prefs_v7";

    /* ==========================
       STATE
       ========================== */
    let selectedWpm = 300;

    let currentDocName = "";
    let currentDocText = "";
    let lastPersistedIdx = -1;

    let words = [];
    let idx = 0;
    let timer = null;
    let isPlaying = false;

    let sentenceStarts = [];
    let wordToSentence = [];

    /* ==========================
       DOM
       ========================== */
    const wpmSlider = document.getElementById('wpmSlider');
    const wpmLabel  = document.getElementById('wpmLabel');

    const sizeSlider = document.getElementById('sizeSlider');
    const sizeLabel = document.getElementById('sizeLabel');

    const pdfBtn = document.getElementById('pdfBtn');
    const pdfInput = document.getElementById('pdfInput');
    const pdfStatus = document.getElementById('pdfStatus');

    const saveName = document.getElementById('saveName');
    const saveBtn = document.getElementById('saveBtn');
    const savedSelect = document.getElementById('savedSelect');
    const loadBtn = document.getElementById('loadBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const restartBtn = document.getElementById('restartBtn');

    const resumeHint = document.getElementById('resumeHint');

    const textInput = document.getElementById('textInput');
    const startBtn = document.getElementById('startBtn');
    const clearBtn = document.getElementById('clearBtn');

    const overlay = document.getElementById('overlay');
    const exitBtn = document.getElementById('exitBtn');

    const progressFill = document.getElementById('progressFill');

    const backBtn = document.getElementById('backBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const nextBtn = document.getElementById('nextBtn');

    const wordInner = document.getElementById('wordInner');

    /* ==========================
       CANVAS MEASUREMENT (for perfect ORP centering)
       ========================== */
    const measureCanvas = document.createElement("canvas");
    const measureCtx = measureCanvas.getContext("2d");

    function updateMeasureFont() {
      const cs = getComputedStyle(wordInner);
      // cs.font is often empty on iOS; build it manually
      const fontWeight = cs.fontWeight || "900";
      const fontSize = cs.fontSize || "64px";
      const fontFamily = cs.fontFamily || "-apple-system, system-ui, sans-serif";
      measureCtx.font = `${fontWeight} ${fontSize} ${fontFamily}`;
    }

    function measureTextPx(text) {
      return measureCtx.measureText(text || "").width;
    }

    /* ==========================
       HELPERS
       ========================== */
    function normalizeText(str) {
      return (str || "")
        .replace(/\s+/g, ' ')
        .replace(/[“”]/g, '"')
        .replace(/[‘’]/g, "'")
        .trim();
    }

    function tokenizeWords(str) {
      return str.split(' ').filter(Boolean);
    }

    function splitIntoSentences(str) {
      const parts = str.match(/[^.!?]+[.!?]+|[^.!?]+$/g);
      return (parts || []).map(s => s.trim()).filter(Boolean);
    }

    function buildSentenceIndexing(text) {
      const sentences = splitIntoSentences(text);
      const starts = [];
      const map = [];

      let runningWordIndex = 0;
      const allWords = [];

      sentences.forEach((s, si) => {
        const w = tokenizeWords(s);
        if (!w.length) return;

        starts.push(runningWordIndex);
        for (let i = 0; i < w.length; i++) map[runningWordIndex + i] = si;

        allWords.push(...w);
        runningWordIndex += w.length;
      });

      if (!allWords.length) {
        const fallback = tokenizeWords(text);
        fallback.forEach((_, wi) => map[wi] = 0);
        return { words: fallback, sentenceStarts: [0], wordToSentence: map };
      }

      return { words: allWords, sentenceStarts: starts, wordToSentence: map };
    }

    function getOrpIndex(word) {
      const len = word.length;
      const lettersOnly = word.replace(/[^A-Za-z0-9ÅÆØåæø]/g, '');
      if (!lettersOnly) return Math.min(0, len - 1);

      let orp = Math.round(len * 0.35);
      if (len <= 1) orp = 0;
      else if (len === 2) orp = 0;
      else orp = Math.max(1, Math.min(len - 2, orp));
      return orp;
    }

    function msPerWord(wpm) { return 60000 / wpm; }
    function extraDelay(word) {
      if (/[.!?]$/.test(word)) return 220;
      if (/[,;:]$/.test(word)) return 120;
      if ((word || "").length >= 10) return 80;
      return 0;
    }

    function updateProgressBar() {
      const total = Math.max(1, words.length);
      const p = Math.max(0, Math.min(1, idx / total));
      progressFill.style.width = (p * 100).toFixed(2) + "%";
    }

    /* ==========================
       ORP-LOCKED RENDERING (NO SPACING ARTIFACTS)
       - render word normally
       - measure left width and total width
       - shift the entire word so ORP sits at X=0 (anchor)
       ========================== */
    function showWordOrpLocked(word) {
      const w = word || "";
      const orp = getOrpIndex(w);

      const left = w.slice(0, orp);
      const center = w[orp] ?? "";
      const right = w.slice(orp + 1);

      // Render as a normal word (no forced gaps)
      wordInner.innerHTML =
        `${escapeHtml(left)}<span class="center">${escapeHtml(center)}</span>${escapeHtml(right)}`;

      // Update measure font and compute shift
      updateMeasureFont();

      const totalW = measureTextPx(w);
      const leftW  = measureTextPx(left);
      const centerW = measureTextPx(center || ""); // typically 1 char

      // ORP position from left edge of word: leftW + centerW/2
      // If word is centered normally, ORP is not fixed.
      // We shift word so ORP aligns to the anchor x=0:
      // shiftX = (totalW/2) - (leftW + centerW/2)
      const shiftX = (totalW * 0.5) - (leftW + centerW * 0.5);

      wordInner.style.transform = `translateX(${shiftX.toFixed(2)}px)`;
    }

    function escapeHtml(s) {
      return (s || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    /* ==========================
       STORAGE
       ========================== */
    function loadSavedTexts() {
      try { return JSON.parse(localStorage.getItem(STORE_KEY_TEXTS) || "{}"); }
      catch { return {}; }
    }
    function saveSavedTexts(map) {
      localStorage.setItem(STORE_KEY_TEXTS, JSON.stringify(map));
    }
    function refreshSavedDropdown() {
      const map = loadSavedTexts();
      const current = savedSelect.value;

      savedSelect.innerHTML = '<option value="">Load saved text…</option>';
      Object.keys(map).sort((a,b)=>a.localeCompare(b)).forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        savedSelect.appendChild(opt);
      });

      if (current && map[current]) savedSelect.value = current;
    }

    function persistProgressIfPossible(force=false) {
      if (!currentDocName || !words.length) return;
      if (!force && idx === lastPersistedIdx) return;

      const map = loadSavedTexts();
      const entry = map[currentDocName];
      if (!entry) return;
      if ((entry.text || "") !== currentDocText) return;

      entry.progressWordIndex = Math.max(0, Math.min(words.length - 1, idx));
      entry.updatedAt = Date.now();
      map[currentDocName] = entry;

      saveSavedTexts(map);
      lastPersistedIdx = idx;
      updateResumeHint();
    }

    function updateResumeHint() {
      const map = loadSavedTexts();
      if (!currentDocName || !map[currentDocName]) {
        resumeHint.textContent = "No saved progress loaded.";
        return;
      }
      const e = map[currentDocName];
      const totalWords = tokenizeWords(normalizeText(e.text || "")).length || 1;
      const prog = Math.max(0, Math.min(totalWords, e.progressWordIndex || 0));
      const pct = Math.round((prog / totalWords) * 100);
      resumeHint.textContent = `Loaded: "${currentDocName}" • Resume at ${pct}%`;
    }

    /* ==========================
       PREFS
       ========================== */
    function loadPrefs() {
      try { return JSON.parse(localStorage.getItem(STORE_KEY_PREFS) || "{}"); }
      catch { return {}; }
    }
    function savePrefs() {
      localStorage.setItem(STORE_KEY_PREFS, JSON.stringify({
        wpm: selectedWpm,
        scale: parseFloat(sizeSlider.value)
      }));
    }
    function setRsvpScale(scale) {
      document.documentElement.style.setProperty('--rsvpScale', String(scale));
      sizeLabel.textContent = Math.round(scale * 100) + "%";
    }
    function applyPrefs() {
      const prefs = loadPrefs();

      if (prefs.wpm) {
        const w = Math.max(100, Math.min(900, Math.round(prefs.wpm / 100) * 100));
        selectedWpm = w;
        wpmSlider.value = String(w);
      } else {
        selectedWpm = parseInt(wpmSlider.value, 10);
      }
      wpmLabel.textContent = String(selectedWpm);

      if (prefs.scale) {
        const s = Math.max(0.2, Math.min(2.0, prefs.scale));
        sizeSlider.value = s;
        setRsvpScale(s);
      } else {
        setRsvpScale(parseFloat(sizeSlider.value));
      }
    }

    /* ==========================
       UI EVENTS
       ========================== */
    wpmSlider.addEventListener('input', () => {
      selectedWpm = parseInt(wpmSlider.value, 10);
      wpmLabel.textContent = String(selectedWpm);
      savePrefs();
    });

    sizeSlider.addEventListener('input', () => {
      setRsvpScale(parseFloat(sizeSlider.value));
      savePrefs();

      // re-measure on size changes to keep ORP stable
      if (overlay.classList.contains("show") && words.length) {
        const w = words[Math.max(0, Math.min(words.length-1, Math.max(0, idx-1)))];
        showWordOrpLocked(w);
      }
    });

    /* ==========================
       PLAYBACK
       ========================== */
    function updateControlState() {
      pauseBtn.textContent = isPlaying ? "Pause" : "Play";

      if (!words.length) {
        backBtn.disabled = true;
        nextBtn.disabled = true;
        return;
      }

      const s = getCurrentSentenceIndex();
      backBtn.disabled = (s <= 0);
      nextBtn.disabled = (s >= sentenceStarts.length - 1);
    }

    function step() {
      if (!isPlaying) return;
      if (idx >= words.length) { pause(); return; }

      const w = words[idx++];
      showWordOrpLocked(w);

      updateProgressBar();
      persistProgressIfPossible(false);

      const delay = msPerWord(selectedWpm) + extraDelay(w);
      clearTimeout(timer);
      timer = setTimeout(step, delay);
    }

    function play() {
      if (!words.length) return;
      isPlaying = true;
      updateControlState();
      step();
    }

    function pause() {
      isPlaying = false;
      clearTimeout(timer);
      timer = null;
      persistProgressIfPossible(true);
      updateControlState();
    }

    function togglePlayPause() {
      if (!overlay.classList.contains('show')) return;
      if (isPlaying) pause();
      else play();
    }

    function enterReadingMode() {
      overlay.classList.add('show');
      document.body.style.overflow='hidden';
      updateControlState();
    }

    function exitReadingMode() {
      pause();
      overlay.classList.remove('show');
      document.body.style.overflow='';
    }

    /* ==========================
       Sentence navigation (buttons)
       ========================== */
    function getCurrentSentenceIndex() {
      const at = Math.max(0, Math.min(words.length - 1, Math.max(0, idx - 1)));
      return wordToSentence[at] ?? 0;
    }

    function jumpToSentence(sentenceIndex) {
      if (!sentenceStarts.length) return;
      const s = Math.max(0, Math.min(sentenceStarts.length - 1, sentenceIndex));
      idx = sentenceStarts[s];

      idx = Math.max(0, Math.min(words.length - 1, idx));
      showWordOrpLocked(words[idx] || "");
      updateProgressBar();
      persistProgressIfPossible(true);

      // stay paused after jump
      pause();
      updateControlState();
    }

    backBtn.addEventListener('click', () => {
      if (!words.length) return;
      jumpToSentence(getCurrentSentenceIndex() - 1);
    });

    nextBtn.addEventListener('click', () => {
      if (!words.length) return;
      jumpToSentence(getCurrentSentenceIndex() + 1);
    });

    pauseBtn.addEventListener('click', () => togglePlayPause());

    /* ==========================
       Save/Load
       ========================== */
    saveBtn.addEventListener('click', ()=>{
      const name=(saveName.value||"").trim();
      const text=normalizeText(textInput.value||"");
      if(!name){alert("Give it a name first.");return;}
      if(!text){alert("Nothing to save — paste some text first.");return;}

      const map=loadSavedTexts();
      const prev=map[name];

      let progressWordIndex=0;
      if(prev && (prev.text||"")===text) progressWordIndex=prev.progressWordIndex||0;

      map[name]={text, progressWordIndex, updatedAt:Date.now()};
      saveSavedTexts(map);

      currentDocName=name;
      currentDocText=text;

      refreshSavedDropdown();
      savedSelect.value=name;
      updateResumeHint();
      alert("Saved ✅");
    });

    loadBtn.addEventListener('click', ()=>{
      const name=savedSelect.value;
      if(!name){alert("Pick a saved item to load.");return;}
      const map=loadSavedTexts();
      const entry=map[name];
      if(!entry){alert("That saved text is missing.");refreshSavedDropdown();return;}

      currentDocName=name;
      currentDocText=normalizeText(entry.text||"");
      textInput.value=currentDocText;
      updateResumeHint();
    });

    deleteBtn.addEventListener('click', ()=>{
      const name=savedSelect.value;
      if(!name){alert("Pick a saved item to delete.");return;}
      if(!confirm(`Delete "${name}"?`)) return;

      const map=loadSavedTexts();
      delete map[name];
      saveSavedTexts(map);

      if(currentDocName===name){currentDocName="";currentDocText="";}
      refreshSavedDropdown();
      updateResumeHint();
    });

    restartBtn.addEventListener('click', ()=>{
      if(!currentDocName){alert("Load a saved text to restart its progress.");return;}
      const map=loadSavedTexts();
      const entry=map[currentDocName];
      if(!entry) return;

      entry.progressWordIndex=0;
      entry.updatedAt=Date.now();
      map[currentDocName]=entry;
      saveSavedTexts(map);

      updateResumeHint();
      alert("Progress reset ✅");
    });

    clearBtn.addEventListener('click', ()=>{
      textInput.value="";
      currentDocName="";
      currentDocText="";
      updateResumeHint();
    });

    /* ==========================
       START READING
       ========================== */
    startBtn.addEventListener('click', ()=>{
      const raw=normalizeText(textInput.value||"");
      if(!raw){alert("Paste some text first.");return;}

      const built=buildSentenceIndexing(raw);
      words=built.words;
      sentenceStarts=built.sentenceStarts;
      wordToSentence=built.wordToSentence;

      idx=0;

      if(currentDocName){
        const map=loadSavedTexts();
        const entry=map[currentDocName];
        if(entry && normalizeText(entry.text||"")===raw){
          currentDocText=raw;
          idx=Math.max(0, Math.min(words.length-1, entry.progressWordIndex||0));
        } else {
          currentDocText=raw;
          idx=0;
        }
      } else {
        currentDocText=raw;
      }

      lastPersistedIdx=-1;

      enterReadingMode();
      showWordOrpLocked(words[idx]||"");
      updateProgressBar();
      play();
    });

    exitBtn.addEventListener('click', ()=>exitReadingMode());

    /* ==========================
       PDF IMPORT (robust)
       ========================== */
    pdfBtn.addEventListener('click', ()=>{
      pdfInput.value="";
      pdfInput.click();
    });

    async function renderPageToCanvas(page, scale=2.1){
      const viewport = page.getViewport({ scale });
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d", { willReadFrequently:true });
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      await page.render({ canvasContext:ctx, viewport }).promise;
      return canvas;
    }

    function cleanOcrText(t){
      return normalizeText(
        (t||"")
          .replace(/-\s+/g, "")
          .replace(/\n{3,}/g, "\n\n")
          .replace(/[ \t]{2,}/g, " ")
      );
    }

    async function extractPdfTextOrOcr(file){
      const buf = await file.arrayBuffer();
      const uint8 = new Uint8Array(buf);

      pdfStatus.textContent = "Opening PDF…";

      const loadingTask = pdfjsLib.getDocument({ data: uint8, disableWorker: true });
      const pdf = await loadingTask.promise;

      const pageCount = pdf.numPages;

      const worker = await Tesseract.createWorker("eng");

      const OCR_TEXT_THRESHOLD = 60;
      const MAX_OCR_PAGES = 40;
      let ocrUsed = 0;

      const out = [];

      try {
        for (let p = 1; p <= pageCount; p++) {
          pdfStatus.textContent = `Reading PDF… Page ${p}/${pageCount}`;
          const page = await pdf.getPage(p);

          let fastText = "";
          try {
            const content = await page.getTextContent();
            const strings = content.items.map(it => (it.str || "").trim()).filter(Boolean);
            fastText = strings.join(" ");
          } catch {
            fastText = "";
          }

          const fastLen = normalizeText(fastText).length;
          const shouldOcr = fastLen < OCR_TEXT_THRESHOLD;

          if (!shouldOcr) {
            out.push(normalizeText(fastText));
            continue;
          }

          if (ocrUsed >= MAX_OCR_PAGES) {
            out.push(normalizeText(fastText));
            continue;
          }

          ocrUsed++;
          pdfStatus.textContent = `OCR… Page ${p}/${pageCount}`;
          const canvas = await renderPageToCanvas(page, 2.2);
          const { data } = await worker.recognize(canvas);
          const ocrText = cleanOcrText(data?.text || "");
          out.push(ocrText || normalizeText(fastText));
        }
      } finally {
        await worker.terminate();
      }

      return { text: normalizeText(out.filter(Boolean).join("\n\n")), pages: pageCount, ocrPages: ocrUsed };
    }

    pdfInput.addEventListener('change', async ()=>{
      const file = pdfInput.files && pdfInput.files[0];
      if (!file) return;

      pdfStatus.textContent = "Loading PDF…";

      try {
        const res = await extractPdfTextOrOcr(file);
        if (!res.text) {
          pdfStatus.textContent = "PDF loaded, but no readable text found.";
          alert("No readable text found.");
          return;
        }

        textInput.value = res.text;

        const k = Math.round(res.text.length / 1000);
        pdfStatus.textContent = res.ocrPages > 0
          ? `PDF loaded ✅ (${res.pages} pages, OCR ${res.ocrPages}p, ~${k}k chars)`
          : `PDF loaded ✅ (${res.pages} pages, ~${k}k chars)`;

      } catch (err) {
        pdfStatus.textContent = "PDF load failed ❌";
        alert("PDF load failed on this device.");
      }
    });

    /* ==========================
       INIT
       ========================== */
    function init() {
      applyPrefs();
      refreshSavedDropdown();
      updateResumeHint();
      updateControlState();

      // ensures initial font is measurable
      updateMeasureFont();

      savedSelect.addEventListener('change', ()=>{
        const name=savedSelect.value;
        if(!name) return;
        const map=loadSavedTexts();
        const entry=map[name];
        if(!entry) return;
        currentDocName=name;
        currentDocText=normalizeText(entry.text||"");
        updateResumeHint();
      });

      // if device rotates, re-render current word with updated font metrics
      window.addEventListener("resize", () => {
        updateMeasureFont();
        if (overlay.classList.contains("show") && words.length) {
          const w = words[Math.max(0, Math.min(words.length-1, Math.max(0, idx-1)))];
          showWordOrpLocked(w);
        }
      }, { passive:true });
    }

    init();
  </script>
</body>
</html>
